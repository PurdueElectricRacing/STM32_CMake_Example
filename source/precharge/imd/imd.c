/**
* @file imd.c
* @author Michael Gliane (mgliane@purdue.edu)
* @brief
* @version 0.1
* @date 2023-9-30
* 
* @copyright Copyright (c) 2023
*
*/

#include "imd.h"

int mhs_frequency[100];
int mls_frequency[100];
int mhs_arrayidx = 0;
int mls_arrayidx = 0;

/**
* @brief                Enabling and configuring the proper GPIO pins (GPIOB pins 5-7)
*                       to read IMD channels
*/
void setup_IMDReading()  {
    RCC -> AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
    GPIOB -> MODER &= ~(0x3 << 14); // Setting GPIOB pin 7 to general input mode (to read OKhs signal)
    GPIOB -> MODER &= ~(0xf << 10); // Setting GPIOB pin 5-6 to general mode (to read duty signals Mhs and Mls)
}

/**
* @brief                Enabling and configuring Timer 3 and 4 for reading IMD
*                       frequency. The capture frequency (100Hz) is twice the maximum
*                       frequency of the IMD (50Hz).
*/
void PHAL_setupTIMClk() {
    // Enabling Timer Clock 3
    RCC -> APB1ENR |= RCC_AHB1ENR_TIM3EN;
    TIM3 -> PSC = (TargetCoreClockrateHz / 10000) - 1;  // Divides 80MHz by 8000 (=10000Hz)
    TIM3 -> ARR = 100 - 1;                              // Divides 10kHz by 100 (=100Hz)
    
    TIM3 -> DIER |= TIM_DIER_UIE;                       // Enables update interrupt
    TIM3 -> CR1 |= TIM_CR1_CEN;
    NVIC -> ISER[0] |= 1 << TIM3_IRQn;


    // Enabling Timer Clock 4
    RCC -> APB1ENR |= RCC_AHB1ENR_TIM4EN;
    TIM4 -> PSC = (TargetCoreClockrateHz / 10000) - 1;  // Divides 80MHz by 8000 (=10000Hz)
    TIM4 -> ARR = 100 - 1;                              // Divides 10kHz by 100 (=100Hz)

    TIM4 -> DIER |= TIM_DIER_UIE;                       // Enables update interrupt
    TIM4 -> CR1 |= TIM_CR1_CEN;
    NVIC -> ISER[0] |= 1 << TIM4_IRQn;
}

/**
* @brief                Handles the interrupt generated by TIM3. This will read the
*                       current value on GPIOB pin 5 and add its value to the corresponding
*                       array (mhs_frequency[])
*/
void TIM3_IRQHandler() {
    mhs_frequency[mhs_array_idx] = (GPIOB -> IDR >> 5) & 1;
    mhs_arrayidx = (mhs_array_idx + 1) % 100;
}

/**
* @brief                Handles the interrupt generated by TIM4. This will read the
*                       current value on GPIOB pin 6 and add its value to the corresponding
*                       array (mls_frequency[])
*/
void TIM4_IRQHandler() {
    mls_frequency[mls_array_idx] = (GPIOB -> IDR >> 6) & 1;
    mls_arrayidx = (mls_array_idx + 1) % 100;
}

/**
* @brief                Checks if the IMD's OKhs signal is high, signaling that there
*                       is no faulty resistance
*
*/
bool checkIMD_signal_OKhs() {
    if(((GPIOB -> IDR >> 7) & 0x1) == 1) { // Checking GPIOB pin 7 to see if input is high
        return true;                // No fault detected
    }
    return false;                   // Fault detected
}

/**
* @brief                Checks and returns the frequency of the Mhs
*/
int checkIMD_signal_Mhs() {
    int cap_frequency = 0;
    
    TIM3 -> CR1 &= TIM_CR1_CEN;     // Temporarily turning off TIM3 to avoid new values whilst reading
    for (int freq_idx = 0; freq_idx < 100; freq_idx++) {
        // If array value == 1, increase the captured frequncy by 1
        mhs_frequency[freq_idx] == 1? cap_frequency += 1 : cap_frequency += 0;
    }
    cap_frequency /= 2;             // Dividing captured frequncy by 2 so that the maximum return value is 50
    TIM3 -> CR1 |= TIM_CR1_CEN;

    return cap_frequency;
}

/**
* @brief                Checks and returns the frequency of the Mls
*/
int checkIMD_signal_Mls() {
    int cap_frequency = 0;
    
    TIM4 -> CR1 &= TIM_CR1_CEN;     // Temporarily turning off TIM3 to avoid new values whilst reading
    for (int freq_idx = 0; freq_idx < 100; freq_idx++) {
        // If array value == 0, increase the captured frequency by 1
        mls_frequency[freq_idx] == 0? cap_frequency += 1 : cap_frequency += 0;
    }
    cap_frequency /= 2;             // Dividing captured frequncy by 2 so that the maximum return value is 50
    TIM4 -> CR1 |= TIM_CR1_CEN;

    return cap_frequency;
}